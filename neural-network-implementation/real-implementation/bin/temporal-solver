#!/usr/bin/env node

const { spawn } = require('child_process');
const path = require('path');
const os = require('os');

// Determine the platform-specific binary
const platform = os.platform();
const arch = os.arch();

let binaryName = 'temporal-solver';
if (platform === 'win32') {
  binaryName += '.exe';
}

// Path to the Rust binary
const binaryPath = path.join(__dirname, '..', 'target', 'release', binaryName);

// Check if AVX2 is supported
function hasAVX2Support() {
  try {
    const cpuInfo = require('os').cpus()[0].model;
    // This is a simple heuristic - real detection would be more complex
    return !cpuInfo.includes('ARM') && !cpuInfo.includes('Apple M');
  } catch {
    return false;
  }
}

// Spawn the Rust binary with arguments
const args = process.argv.slice(2);

// Add performance flags based on CPU capabilities
if (hasAVX2Support()) {
  console.log('✅ AVX2 support detected - using optimized path');
} else {
  console.log('⚠️  AVX2 not detected - using fallback implementation');
}

const child = spawn(binaryPath, args, {
  stdio: 'inherit',
  env: {
    ...process.env,
    RUST_BACKTRACE: '1'
  }
});

child.on('error', (err) => {
  if (err.code === 'ENOENT') {
    console.error('❌ Binary not found. Please run: npm run build');
    process.exit(1);
  }
  console.error('Error:', err);
  process.exit(1);
});

child.on('exit', (code) => {
  process.exit(code || 0);
});